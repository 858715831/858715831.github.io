(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{397:function(t,v,a){"use strict";a.r(v);var _=a(4),r=Object(_.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h3",{attrs:{id:"事务的四大特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务的四大特性"}},[t._v("#")]),t._v(" 事务的四大特性")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("原子性")]),t._v("：事务里的操作要么全部运行，要么不运行")]),t._v(" "),v("li",[v("strong",[t._v("一致性")]),t._v("：正确性，操作前后保证正确")]),t._v(" "),v("li",[v("strong",[t._v("持久性")]),t._v("：事务提交提交后")]),t._v(" "),v("li",[v("strong",[t._v("隔离性")]),t._v("：事务与事务之间互不干扰")])]),t._v(" "),v("h3",{attrs:{id:"数据库三大范式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据库三大范式"}},[t._v("#")]),t._v(" 数据库三大范式")]),t._v(" "),v("ul",[v("li",[t._v("1NF：所有字段不可拆分")]),t._v(" "),v("li",[t._v("2NF：非主字段完全依赖主键，而不是依赖一部分")]),t._v(" "),v("li",[t._v("3NF：没有传递依赖")])]),t._v(" "),v("h3",{attrs:{id:"事务的隔离级别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务的隔离级别"}},[t._v("#")]),t._v(" 事务的隔离级别")]),t._v(" "),v("ul",[v("li",[t._v("read uncommitted（读未提交RU）：所有问题都存在")]),t._v(" "),v("li",[t._v("read commiteed（读已提交RC）：解决脏读")]),t._v(" "),v("li",[t._v("repeatable read（可重复读RR）：默认，解决不可重复度")]),t._v(" "),v("li",[t._v("serialzable（串行化）：解决幻读")])]),t._v(" "),v("h3",{attrs:{id:"脏读、不可重复读、幻读"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#脏读、不可重复读、幻读"}},[t._v("#")]),t._v(" 脏读、不可重复读、幻读")]),t._v(" "),v("p",[t._v("脏读：读到了可能未被提交的数据\n不可重复读：一次事务内读的两次数据不一致\n幻读：读的时候数据不存在，插入时数据又存在了")]),t._v(" "),v("h3",{attrs:{id:"生产环境用什么级别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#生产环境用什么级别"}},[t._v("#")]),t._v(" 生产环境用什么级别")]),t._v(" "),v("p",[t._v("用RC，")]),t._v(" "),v("h3",{attrs:{id:"utf8与utf8mb4对比"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#utf8与utf8mb4对比"}},[t._v("#")]),t._v(" utf8与utf8mb4对比")]),t._v(" "),v("ul",[v("li",[t._v("utf8mb3：most bytes 3，最大三字节，只支持部分字符，不能存emoji")]),t._v(" "),v("li",[t._v("utf8mb4：most bytes 4，最大四字节，支持几乎所有字符，能存emoji")])]),t._v(" "),v("h3",{attrs:{id:"那utf8mb4对比utf8有什么劣势吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#那utf8mb4对比utf8有什么劣势吗"}},[t._v("#")]),t._v(" 那utf8mb4对比utf8有什么劣势吗")]),t._v(" "),v("p",[t._v("空间劣势，例如：char(2)是指字符个数为2")]),t._v(" "),v("ul",[v("li",[t._v("utf8mb3，保留 2 * 3 (maxlen=3) = 6个字节的空间。")]),t._v(" "),v("li",[t._v("utf8mb4，保留2*4（maxlen=4）= 8个字节的空间。")])]),t._v(" "),v("h3",{attrs:{id:"索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#索引"}},[t._v("#")]),t._v(" 索引")]),t._v(" "),v("h4",{attrs:{id:"什么是索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是索引"}},[t._v("#")]),t._v(" 什么是索引")]),t._v(" "),v("p",[t._v("索引是一棵B+树或者哈希表，用来提升数据排序、搜索速度")]),t._v(" "),v("h4",{attrs:{id:"索引优缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#索引优缺点"}},[t._v("#")]),t._v(" 索引优缺点")]),t._v(" "),v("ul",[v("li",[t._v("优点：提升查询排序速度")]),t._v(" "),v("li",[t._v("缺点：插入修改时间增加；空间消耗大")])]),t._v(" "),v("h4",{attrs:{id:"什么情况下需要建索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么情况下需要建索引"}},[t._v("#")]),t._v(" 什么情况下需要建索引？")]),t._v(" "),v("p",[t._v("对速度有要求且经常使用的字段（查询，连接，排序）")]),t._v(" "),v("h4",{attrs:{id:"什么情况下不建索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么情况下不建索引"}},[t._v("#")]),t._v(" 什么情况下不建索引？")]),t._v(" "),v("ul",[v("li",[t._v("where条件中用不到的字段不适合建立索引")]),t._v(" "),v("li",[t._v("表记录较少。比如只有几百条数据，没必要加索引。")]),t._v(" "),v("li",[t._v("需要经常增删改。需要评估是否适合加索引")]),t._v(" "),v("li",[v("strong",[t._v("参与列计算的列")]),t._v("不适合建索引")]),t._v(" "),v("li",[t._v("区分度不高的字段不适合建立索引，如性别，只有男/女/未知三个值。加了索引，查询效率也不会提高。")])]),t._v(" "),v("h4",{attrs:{id:"hash索引和b-树索引的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#hash索引和b-树索引的区别"}},[t._v("#")]),t._v(" Hash索引和B+树索引的区别")]),t._v(" "),v("ul",[v("li",[t._v("哈希索引不支持排序，因为哈希表是无序的。")]),t._v(" "),v("li",[t._v("哈希索引不支持范围查找。")]),t._v(" "),v("li",[t._v("哈希索引不支持模糊查询及多列索引的最左前缀匹配。")]),t._v(" "),v("li",[t._v("因为哈希表中会存在哈希冲突，所以哈希索引的性能是不稳定的，而B+树索引的性能是相对稳定的，每次查询都是从根节点到叶子节点。")])]),t._v(" "),v("h4",{attrs:{id:"为什么b-树比b树更适合实现数据库索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么b-树比b树更适合实现数据库索引"}},[t._v("#")]),t._v(" 为什么B+树比B树更适合实现数据库索引？")]),t._v(" "),v("ul",[v("li",[t._v("B树所有节点都存数据，增加了树高；")]),t._v(" "),v("li",[t._v("B+树叶子节点存数据，扫表只要扫底部双向链表就行")])]),t._v(" "),v("h4",{attrs:{id:"索引有什么分类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#索引有什么分类"}},[t._v("#")]),t._v(" 索引有什么分类")]),t._v(" "),v("ul",[v("li",[t._v("主键索引")]),t._v(" "),v("li",[t._v("唯一索引")]),t._v(" "),v("li",[t._v("组合索引")]),t._v(" "),v("li",[t._v("全文索引：只能在char、varchar和text")]),t._v(" "),v("li",[t._v("普通索引")])]),t._v(" "),v("h4",{attrs:{id:"什么是最左匹配原则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是最左匹配原则"}},[t._v("#")]),t._v(" 什么是最左匹配原则")]),t._v(" "),v("p",[t._v("使用组合索引前缀子串走索引。同时遇到范围查询(>、<、between、like)就会停止匹配，后面不使用索引")]),t._v(" "),v("ul",[v("li",[t._v("对(a,b,c)建立索引，查询条件使用 a/ab/abc 会走索引，使用 bc 不会走索引。")]),t._v(" "),v("li",[t._v("对(a,b,c,d)建立索引，查询条件为a = 1 and b = 2 and c > 3 and d = 4，那么a、b和c三个字段能用到索引，而d无法使用索引。因为遇到了范围查询。")])]),t._v(" "),v("blockquote",[v("p",[t._v("所以尽可能使用 =>、<=")])]),t._v(" "),v("h4",{attrs:{id:"什么是覆盖索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是覆盖索引"}},[t._v("#")]),t._v(" 什么是覆盖索引")]),t._v(" "),v("p",[t._v("select的数据列只用从索引中就能够取得，不需要回表进行二次查询，也就是说查询列要被所使用的索引覆盖。对于innodb表的二级索引，如果索引能覆盖到查询的列，那么就可以避免对主键索引的二次查询。")]),t._v(" "),v("h4",{attrs:{id:"索引的设计原则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#索引的设计原则"}},[t._v("#")]),t._v(" 索引的设计原则")]),t._v(" "),v("ul",[v("li",[t._v("对于经常作为查询条件的字段，应该建立索引，以提高查询速度为")]),t._v(" "),v("li",[t._v("经常需要排序、分组和联合操作的字段建立索引")]),t._v(" "),v("li",[t._v("索引列的区分度越高，索引的效果越好。比如使用性别这种区分度很低的列作为索引，效果就会很差。")]),t._v(" "),v("li",[t._v('避免给"大字段"建立索引。尽量使用数据量小的字段作为索引。因为MySQL在维护索引的时候是会将字段值一起维护的，那这样必然会导致索引占用更多的空间，另外在排序的时候需要花费更多的时间去对比。')]),t._v(" "),v("li",[t._v("尽量使用短索引，对于较长的字符串进行索引时应该指定一个较短的前缀长度，因为较小的索引涉及到的磁盘I/O较少，查询速度更快。")]),t._v(" "),v("li",[t._v("索引不是越多越好，每个索引都需要额外的物理空间，维护也需要花费时间。")]),t._v(" "),v("li",[t._v("频繁增删改的字段不要建立索引。假设某个字段频繁修改，那就意味着需要频繁的重建索引，这必然影响MySQL的性能")]),t._v(" "),v("li",[t._v("利用最左前缀原则。")])]),t._v(" "),v("h4",{attrs:{id:"索引什么时候会失效"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#索引什么时候会失效"}},[t._v("#")]),t._v(" 索引什么时候会失效")]),t._v(" "),v("ul",[v("li",[t._v("对于组合索引，不是使用组合索引最左边的字段，则不会使用索引")]),t._v(" "),v("li",[t._v("以%开头的like查询如%abc，无法使用索引；非%开头的like查询如abc%，相当于范围查询，会使用索引查询条件中")]),t._v(" "),v("li",[t._v("列类型是字符串，没有使用引号，可能会因为类型不同发生隐式转换，使索引失效")]),t._v(" "),v("li",[t._v("判断索引列是否不等于某个值时")]),t._v(" "),v("li",[t._v("对索引列进行运算查询条件")]),t._v(" "),v("li",[t._v("当or连接的条件，左右两侧字段都有索引时，索引才会生效")])]),t._v(" "),v("h4",{attrs:{id:"什么是前缀索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是前缀索引"}},[t._v("#")]),t._v(" 什么是前缀索引")]),t._v(" "),v("p",[t._v("前缀索引是指对文本或者字符串的前几个字符建立索引，这样索引的长度更短，查询速度更快。")]),t._v(" "),v("h4",{attrs:{id:"常见的存储引擎及其区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常见的存储引擎及其区别"}},[t._v("#")]),t._v(" 常见的存储引擎及其区别")]),t._v(" "),v("ul",[v("li",[t._v("MyISAM：使用哈希table")]),t._v(" "),v("li",[t._v("InnoDB：使用B+树，支持行锁、事务、外键")])]),t._v(" "),v("h3",{attrs:{id:"锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#锁"}},[t._v("#")]),t._v(" 锁")]),t._v(" "),v("h4",{attrs:{id:"按粒度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#按粒度"}},[t._v("#")]),t._v(" 按粒度")]),t._v(" "),v("ul",[v("li",[t._v("全局锁")]),t._v(" "),v("li",[t._v("表级锁")]),t._v(" "),v("li",[t._v("行级锁")])]),t._v(" "),v("h4",{attrs:{id:"其他"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#其他"}},[t._v("#")]),t._v(" 其他")]),t._v(" "),v("ul",[v("li",[t._v("共享锁（S锁、读锁）")]),t._v(" "),v("li",[t._v("排他锁（X锁、写锁）")]),t._v(" "),v("li",[t._v("意向锁：防止行锁与表锁冲突")]),t._v(" "),v("li",[t._v("元数据锁：事务对数据增删改查时防止表结构被改变")])]),t._v(" "),v("h3",{attrs:{id:"mvcc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mvcc"}},[t._v("#")]),t._v(" MVCC")]),t._v(" "),v("h4",{attrs:{id:"mvc实现原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mvc实现原理"}},[t._v("#")]),t._v(" MVC实现原理")]),t._v(" "),v("p",[t._v("Multi-Version Concurrency Control，多版本并发控制，原理3个隐藏字段、undolog、readview")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"left"}},[t._v("隐藏字段")]),t._v(" "),v("th",{staticStyle:{"text-align":"left"}},[t._v("含义")])])]),t._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"left"}},[t._v("DB_TRX_ID")]),t._v(" "),v("td",{staticStyle:{"text-align":"left"}},[t._v("最近修改事务ID")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[t._v("DB_ROLL_PTR")]),t._v(" "),v("td",{staticStyle:{"text-align":"left"}},[t._v("回滚指针，指向这条记录的上一个版本，用于配合undo log")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[t._v("DB_ROW_ID")]),t._v(" "),v("td",{staticStyle:{"text-align":"left"}},[t._v("隐藏主键，如果没有主键，会生成该隐藏字段。")])])])]),t._v(" "),v("h4",{attrs:{id:"当前读与快照读"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#当前读与快照读"}},[t._v("#")]),t._v(" 当前读与快照读")]),t._v(" "),v("ul",[v("li",[t._v("当前读读最新")]),t._v(" "),v("li",[t._v("快照读读读之前的某个时间节点")])]),t._v(" "),v("h3",{attrs:{id:"日志"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#日志"}},[t._v("#")]),t._v(" 日志")]),t._v(" "),v("h4",{attrs:{id:"binlog"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#binlog"}},[t._v("#")]),t._v(" binlog")]),t._v(" "),v("p",[t._v("二进制日志，逻辑日志，记录增删改，用于主从复制")]),t._v(" "),v("h4",{attrs:{id:"redo-log"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redo-log"}},[t._v("#")]),t._v(" redo log")]),t._v(" "),v("p",[t._v("重做日志，物理日志，分为内存与磁盘区")]),t._v(" "),v("ul",[v("li",[t._v("重做日志缓冲（redo log buffer），内存中，缓存修改")]),t._v(" "),v("li",[t._v("重做日志文件（redo log file），磁盘中，事务提交后把所有修改信息写入该日志文件")])]),t._v(" "),v("h4",{attrs:{id:"undo-log"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#undo-log"}},[t._v("#")]),t._v(" undo log")]),t._v(" "),v("p",[t._v("回滚日志，逻辑日志")]),t._v(" "),v("blockquote",[v("p",[t._v("Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC")])]),t._v(" "),v("h4",{attrs:{id:"慢查询日志"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#慢查询日志"}},[t._v("#")]),t._v(" 慢查询日志")]),t._v(" "),v("p",[t._v("记录查询慢的操作")]),t._v(" "),v("h4",{attrs:{id:"查询日志"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#查询日志"}},[t._v("#")]),t._v(" 查询日志")]),t._v(" "),v("p",[t._v("记录所有增删改查")]),t._v(" "),v("h4",{attrs:{id:"relay-log"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#relay-log"}},[t._v("#")]),t._v(" Relay Log")]),t._v(" "),v("p",[t._v("中继日志，主从复制环境下，从Slave记录Master的二进制日志的副本")]),t._v(" "),v("h4",{attrs:{id:"bin-log和redo-log有什么区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#bin-log和redo-log有什么区别"}},[t._v("#")]),t._v(" bin log和redo log有什么区别")]),t._v(" "),v("ul",[v("li",[t._v("bin log会记录所有日志记录，包括InnoDB、MyISAM等存储引擎的日志；redo log只记录innoDB自身的事务日志")]),t._v(" "),v("li",[t._v("bin log只在事务提交前写入到磁盘，一个事务只写一次；而在事务进行过程，会有redo log不断写入磁盘")]),t._v(" "),v("li",[t._v("bin log是逻辑日志，记录的是SQL语句的原始逻辑；redo log是物理日志，记录的是在"),v("strong",[t._v("某个数据页上做了什么修改")])])]),t._v(" "),v("h3",{attrs:{id:"mysql单表多大进行分库分表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mysql单表多大进行分库分表"}},[t._v("#")]),t._v(" MySQL单表多大进行分库分表")]),t._v(" "),v("ul",[v("li",[t._v("MySQL 单表数据量大于 2000 万行，性能会明显下降，考虑进行分库分表。")]),t._v(" "),v("li",[t._v("阿里巴巴《Java 开发手册》提出单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。")])]),t._v(" "),v("blockquote",[v("p",[t._v("事实上，这个数值和实际记录的条数无关，而与 MySQL 的配置以及机器的硬件有关。因为MySQL为了提高性能，会将表的索引装载到内存中。在InnoDB buffer size 足够的情况下，其能完成全加载进内存，查询不会有问题。但是，当单表数据库到达某个量级的上限时，导致内存无法存储其索引，使得之后的 SQL 查询会产生磁盘 IO，从而导致性能下降。当然，这个还有具体的表结构的设计有关，最终导致的问题都是内存限制。\n因此，对于分库分表，需要结合实际需求，不宜过度设计，在项目一开始不采用分库与分表设计，而是随着业务的增长，在无法继续优化的情况下，再考虑分库与分表提高系统的性能。对此，阿里巴巴《Java 开发手册》补充到：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。\n至于MySQL单表多大进行分库分表，应当根据机器资源进行评估。")])]),t._v(" "),v("h3",{attrs:{id:"阿里java手册禁止使用存储过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#阿里java手册禁止使用存储过程"}},[t._v("#")]),t._v(" 阿里Java手册禁止使用存储过程")]),t._v(" "),v("p",[t._v("难以维护、测试、移植性差、优化一次性")]),t._v(" "),v("h3",{attrs:{id:"update-是锁行还是锁表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#update-是锁行还是锁表"}},[t._v("#")]),t._v(" update 是锁行还是锁表")]),t._v(" "),v("p",[t._v("首先，InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。")]),t._v(" "),v("ul",[v("li",[t._v("当执行update语句时，where中的过滤条件列，如果用到索引，就是锁行；如果无法用索引，就是锁表。")]),t._v(" "),v("li",[t._v("如果两个update语句同时执行，第一个先执行触发行锁，但是第二个没有索引触发表锁，因为有个行锁住了，所以还是会等待行锁释放，才能锁表。")]),t._v(" "),v("li",[t._v("当执行insert或者delete语句时同理")])]),t._v(" "),v("h3",{attrs:{id:"select-for-update会锁表还是锁行"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#select-for-update会锁表还是锁行"}},[t._v("#")]),t._v(" select...for update会锁表还是锁行？")]),t._v(" "),v("ul",[v("li",[t._v("如果查询条件用了索引/主键，那么select ... for update就会加行锁")]),t._v(" "),v("li",[t._v("如果是普通字段(没有索引/主键)，那么select ..... for update就会加表锁。")])]),t._v(" "),v("h3",{attrs:{id:"mysql的binlog有几种格式-分别有什么区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mysql的binlog有几种格式-分别有什么区别"}},[t._v("#")]),t._v(" MySQL的binlog有几种格式，分别有什么区别")]),t._v(" "),v("p",[t._v("有三种格式，statement，row和mixed")]),t._v(" "),v("ul",[v("li",[t._v("statement：\n"),v("ul",[v("li",[t._v("以sql为单位")]),t._v(" "),v("li",[t._v("记录除了查询的sql语句")]),t._v(" "),v("li",[t._v("日志紧凑，占用空间小")]),t._v(" "),v("li",[t._v("不同数据库状态下产生不同结果")])])]),t._v(" "),v("li",[t._v("row：\n"),v("ul",[v("li",[t._v("以行为单位")]),t._v(" "),v("li",[t._v("记录数据变化")]),t._v(" "),v("li",[t._v("日志大，占用空间多")]),t._v(" "),v("li",[t._v("精准捕捉数据库变化")])])]),t._v(" "),v("li",[t._v("mixed：\n"),v("ul",[v("li",[t._v("二者都有")])])])]),t._v(" "),v("blockquote",[v("p",[t._v("statement相当于逻辑日志，row相当于物理日志")])]),t._v(" "),v("h3",{attrs:{id:"count-字段-、count-主键-、count-1-、、count-区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#count-字段-、count-主键-、count-1-、、count-区别"}},[t._v("#")]),t._v(" count(字段)、count(主键)、count(1)、、count(*)区别")]),t._v(" "),v("ul",[v("li",[t._v("count(1)：遍历表，不取数据，往里面放1，统计数量")]),t._v(" "),v("li",[t._v("count(主键)：遍历表，取主键值，计数")]),t._v(" "),v("li",[t._v("count(字段)：遍历表，取字段值，判断是否有非空索引，判断是否为空，不为空计数")]),t._v(" "),v("li",[t._v("count(*)：遍历表，不取值，做了优化，优先使用开销最小的二级索引")])])])}),[],!1,null,null,null);v.default=r.exports}}]);